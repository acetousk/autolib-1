#pragma once
#include "autolib/util/messages.hpp"
#include "autolib/auto/pathGenerator.hpp"
#include "autolib/auto/purePursuitMath.hpp"
#include "okapi/api/units/QLength.hpp"
#include "okapi/api/units/RQuantity.hpp"
#include <memory>
#include <vector>
#include <cmath>
//*

#define DEBUG

namespace autolib{

class PurePursuit {
    public:
    /**
     * PurePursuit 
     * This is the constructor for PurePursuit. The first param is an InternalPath which should be generated by
     * PathGenerator's getPath() method. The second param is the lookaheadDistance of the Pure Pursuit algorithm.
     * 
     * @param  {InternalPath} ipath                : 
     *  example: pathGenerator.getPath()
     * @param  {okapi::QLength} ilookaheadDistance : 
     *  example: 1_ft
     */
    PurePursuit( const std::vector<PosePath> &ipaths, const okapi::QLength &ilookaheadDistance );

    /**
     * This should be run in a loop during your autonomous. The input is the x, y, and theta in global coordinates 
     * of where your robot is currently located. This can be calculated using okapi's odometry feature. To access
     * that feature go the the feature/odometry branch on github until the official release of it.
     * 
     * @param  {okapi::QLength} ix    : 
     *  example: exampleVariable * foot
     * @param  {okapi::QLength} iy    :
     *  example: exampleVariable * inch 
     * @param  {okapi::QAngle} itheta :
     *  example: exampleVariable * degree
     * @return {Curvature}            :
     *  example: ask me
     */
    Curvature getGoalCurvature( const Pose &ipose, const std::string &iid );

    protected:
    const std::vector<PosePath> paths;
    PosePath &path;
    PosePath possiblePoses;
    PosePath nearestPoses;
    PosePath currentPose;
    PosePath goalPose;
    PosePath localGoalPose;

    double lookaheadDistance;

    void findNearestPose( const InternalPose & );

    void findGoalPose();

    void convertGlobalToLocalPoses();

    Curvature findCurvature();

    void findPossiblePoses( const InternalPose &currentPose, const InternalPose &lastNearestPose, const InternalPath &path, const double &lookaheadDistance );

    bool isPoseWithinCircle( const InternalPose &point, const InternalPose &centerPose, const double &lookaheadDistance );

    double findDistanceBetweenPoses( const InternalPose &P1, const InternalPose &P2 );

    double findLowestValue( const std::vector<double> &list );

    int findLowestValuePos( const std::vector<double> &list, const std::vector<int> &pos );

};

}//autolib
//*/
